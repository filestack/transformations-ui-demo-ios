// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TransformationsUIShared
import AVFoundation
import AVFoundation.AVUtilities
import CoreGraphics
import CoreImage
import Foundation
import MetalKit
import Swift
import UIKit.UIGeometry
import UIKit
import UberSegmentedControl
@objc open class EditorToolbar : ArrangeableToolbar {
  final public let style: EditorToolbarStyle
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  override open func setItems(_ items: [UIKit.UIView] = [], animated: Swift.Bool = false)
  public init(style: EditorToolbarStyle = .default)
  @objc required dynamic public init(coder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init()
  override public init(items: [UIKit.UIView])
}
extension EditorToolbar {
  open func button(using image: UIKit.UIImage) -> UIKit.UIButton
  open func button(using title: Swift.String) -> UIKit.UIButton
  open func button(using title: Swift.String, image: UIKit.UIImage) -> TitledImageButton
  open func label(titled title: Swift.String) -> UIKit.UILabel
}
@objc open class ArrangeableToolbar : UIKit.UIView {
  open var shouldAutoAdjustAxis: Swift.Bool
  open var distribution: UIKit.UIStackView.Distribution {
    get
    set
  }
  open var alignment: UIKit.UIStackView.Alignment {
    get
    set
  }
  open var axis: UIKit.NSLayoutConstraint.Axis {
    get
    set
  }
  open var spacing: CoreGraphics.CGFloat {
    get
    set
  }
  open var items: [UIKit.UIView] {
    get
  }
  open var innerInset: CoreGraphics.CGFloat {
    get
    set
  }
  open func setCustomSpacing(_ spacing: CoreGraphics.CGFloat, after arrangedSubview: UIKit.UIView)
  @objc dynamic public init()
  public init(items: [UIKit.UIView])
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public func addItem(_ item: UIKit.UIView)
  public func insertItem(_ item: UIKit.UIView, at stackIndex: Swift.Int)
  public func removeItem(_ item: UIKit.UIView)
  public func removeAllItems()
  public func setItems(_ items: [UIKit.UIView] = [], animated: Swift.Bool = false)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension ArrangeableToolbar {
  @objc override dynamic open func layoutSubviews()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CIImageView : MetalKit.MTKView {
  @objc dynamic weak public var image: CoreImage.CIImage? {
    @objc get
    @objc set
  }
  @objc override dynamic public init(frame frameRect: CoreGraphics.CGRect, device: Metal.MTLDevice?)
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
public enum BoundedRangeFormat {
  case numeric
  case percent
  case degrees
  public static func == (a: BoundedRangeFormat, b: BoundedRangeFormat) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol BoundedRangeCommand : EditorModuleCommand {
  var defaultValue: Swift.Double { get }
  var range: Swift.Range<Swift.Double> { get }
  var componentLabels: [Swift.String] { get }
  var format: BoundedRangeFormat { get }
  func formattedString(using value: Swift.Double) -> Swift.String
}
extension BoundedRangeCommand {
  public func formattedString(using value: Swift.Double) -> Swift.String
}
@objc @_inheritsConvenienceInitializers public class CenteredScrollView : UIKit.UIScrollView {
  public var extraContentInset: UIKit.UIEdgeInsets {
    get
    set
  }
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol EditDataSource : AnyObject {
  var imageFrame: CoreGraphics.CGRect { get }
  var imageSize: CoreGraphics.CGSize { get }
  var zoomScale: CoreGraphics.CGFloat { get }
  var virtualFrame: CoreGraphics.CGRect { get }
  func convertPointFromVirtualFrameToImageFrame(_ point: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  func convertRectFromVirtualFrameToImageFrame(_ rect: CoreGraphics.CGRect) -> CoreGraphics.CGRect
}
public typealias Snapshot = [Swift.String : Any?]
public protocol Snapshotable {
  func snapshot() -> Snapshot
  func restore(from snapshot: Snapshot)
}
public protocol PointerHashable : AnyObject, Swift.Hashable {
}
extension PointerHashable {
  public static func == (left: Self, right: Self) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol StandardToolbarDelegate : AnyObject {
  func toolbarItemSelected(toolbar: StandardToolbar, item: DescriptibleEditorItem, control: UIKit.UIControl)
}
@objc public class StandardToolbar : EditorToolbar {
  weak public var delegate: StandardToolbarDelegate?
  override public var items: [UIKit.UIView] {
    get
  }
  final public let descriptibleItems: [DescriptibleEditorItem]
  public var selectedItem: UIKit.UIView? {
    get
    set
  }
  public var selectedDescriptibleItem: DescriptibleEditorItem? {
    get
  }
  public var shouldHighlightSelectedItem: Swift.Bool
  override public var spacing: CoreGraphics.CGFloat {
    get
    set
  }
  required public init(items: [DescriptibleEditorItem], style: EditorToolbarStyle = .default)
  @objc required dynamic public init(coder _: Foundation.NSCoder)
  override public func setItems(_ items: [UIKit.UIView] = [], animated: Swift.Bool = false)
  @objc deinit
  override public init(style: EditorToolbarStyle = super)
}
extension StandardToolbar {
  public func setEnabled(item: DescriptibleEditorItem, enabled: Swift.Bool)
}
extension UIEdgeInsets {
  public func rounded(rule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> UIKit.UIEdgeInsets
  public func clipped() -> UIKit.UIEdgeInsets
  public func adding(insets: UIKit.UIEdgeInsets) -> UIKit.UIEdgeInsets
}
@objc public class CircleCropLayer : QuartzCore.CALayer {
  public var imageFrame: CoreGraphics.CGRect {
    get
    set
  }
  public var circleRadius: CoreGraphics.CGFloat {
    get
    set
  }
  public var circleCenter: CoreGraphics.CGPoint {
    get
    set
  }
  @objc override dynamic public init()
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init(layer: Any)
}
extension CircleCropLayer {
  public func updateColors()
}
public protocol EditorModuleCommand : DescriptibleEditorItem {
}
public enum RenderNodeCategory {
  case image
  case object
  case overlay
  case none
  public static func == (a: RenderNodeCategory, b: RenderNodeCategory) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class SegmentedControlToolbar : StandardToolbar {
  required public init(items: [DescriptibleEditorItem], style: EditorToolbarStyle = .segments)
  @objc required dynamic public init(coder _: Foundation.NSCoder)
  @objc deinit
}
extension SegmentedControlToolbar {
  public func resetSelectedSegment(to index: Swift.Int = 0)
}
extension UIView {
  @discardableResult
  public func fill(with subview: UIKit.UIView, connectingEdges: [UIKit.NSLayoutConstraint.Attribute] = [.top, .bottom, .left, .right], inset: CoreGraphics.CGFloat = 0, withSafeAreaRespecting useSafeArea: Swift.Bool = false, activate: Swift.Bool = false) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func connect(edges: [UIKit.NSLayoutConstraint.Attribute], of subview: UIKit.UIView, inset: CoreGraphics.CGFloat = 0, withSafeAreaRespecting useSafeArea: Swift.Bool = false, activate: Swift.Bool = false) -> [UIKit.NSLayoutConstraint]
}
@objc public class RectCropLayer : QuartzCore.CALayer {
  public var imageFrame: CoreGraphics.CGRect {
    get
    set
  }
  public var cropRect: CoreGraphics.CGRect {
    get
    set
  }
  @objc override dynamic public init()
  @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init(layer: Any)
}
extension RectCropLayer {
  public func updateColors()
}
@objc @_inheritsConvenienceInitializers open class ModuleViewController : UIKit.UIViewController, ModuleViewSource {
  open var canvasView: UIKit.UIView? {
    get
    set
  }
  open var zoomEnabled: Swift.Bool {
    get
    set
  }
  open var canScrollAndZoom: Swift.Bool {
    get
    set
  }
  open var scrollView: CenteredScrollView {
    get
  }
  public var activeModuleController: EditorModuleController?
  weak public var discardApplyDelegate: DiscardApplyToolbarDelegate?
  final public let contentView: UIKit.UIView
  final public let stackView: UIKit.UIStackView
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension ModuleViewController {
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidLayoutSubviews()
  @objc override dynamic open func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
}
extension ModuleViewController : UIKit.UIScrollViewDelegate {
  @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
}
extension ModuleViewController : UIKit.UIPopoverPresentationControllerDelegate {
  @objc dynamic public func adaptivePresentationStyle(for controller: UIKit.UIPresentationController) -> UIKit.UIModalPresentationStyle
}
open class RenderNode : PointerHashable {
  final public let uuid: Foundation.UUID
  required public init(uuid: Foundation.UUID? = nil)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
public protocol RenderNodeChange {
}
public protocol RenderNodeDelegate : AnyObject {
  func nodeChanged(node: RenderNode)
  func nodeFinishedChanging(node: RenderNode, change: RenderNodeChange?)
}
public protocol RenderGroupNode : RenderNode, RenderNodeDelegate {
  var delegate: RenderNodeDelegate? { get set }
  func add(node: RenderGroupChildNode)
  func remove(node: RenderGroupChildNode)
  func node(with uuid: Foundation.UUID) -> RenderGroupChildNode?
  func canMoveBack(node: RenderGroupChildNode) -> Swift.Bool
  func canMoveForward(node: RenderGroupChildNode) -> Swift.Bool
  func moveBack(node: RenderGroupChildNode)
  func moveForward(node: RenderGroupChildNode)
}
public protocol RenderGroupChildNode : RenderNode {
  var group: RenderGroupNode? { get set }
}
public protocol IONode : RenderNode {
  var inputImage: CoreImage.CIImage { get set }
  var outputImage: CoreImage.CIImage { get }
}
public protocol ViewableNode : RenderNode {
  var view: UIKit.UIView { get }
}
public protocol ChangeApplyingNode : RenderNode {
  func apply(change: RenderNodeChange?, from node: RenderNode)
}
public protocol ObjectRenderNode : RenderGroupChildNode, ViewableNode {
  var center: CoreGraphics.CGPoint { get set }
  var bounds: CoreGraphics.CGRect { get set }
  var transform: CoreGraphics.CGAffineTransform { get set }
}
public struct EditorToolbarStyle {
  public var backgroundColor: UIKit.UIColor?
  public var innerInset: CoreGraphics.CGFloat
  public var itemSpacing: CoreGraphics.CGFloat
  public var fixedHeight: CoreGraphics.CGFloat?
  public var itemStyle: EditorToolbarItemStyle
  public var axis: UIKit.NSLayoutConstraint.Axis
  public init(_ build: (inout EditorToolbarStyle) -> Swift.Void)
}
public protocol DescriptibleEditorItem : AnyObject {
  var uuid: Foundation.UUID { get }
  var title: Swift.String { get }
  var icon: UIKit.UIImage? { get }
}
extension DescriptibleEditorItem {
  public var icon: UIKit.UIImage? {
    get
  }
}
@objc public class VisualFXWrapperView : UIKit.UIVisualEffectView {
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  public init(wrapping view: UIKit.UIView, usingBlurEffect effect: UIKit.UIBlurEffect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init(effect: UIKit.UIVisualEffect?)
}
@objc public class ToolbarScrollView : CenteredScrollView {
  @objc dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public func touchesShouldCancel(in view: UIKit.UIView) -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct L18 {
  public static let save: Swift.String
  public static let cancel: Swift.String
}
public protocol ModuleViewSource : AnyObject {
  var canvasView: UIKit.UIView? { get }
  var scrollView: CenteredScrollView { get }
  var stackView: UIKit.UIStackView { get }
  var contentView: UIKit.UIView { get }
  var canScrollAndZoom: Swift.Bool { get set }
  var zoomEnabled: Swift.Bool { get set }
  var traitCollection: UIKit.UITraitCollection { get }
  var discardApplyDelegate: DiscardApplyToolbarDelegate? { get }
}
public protocol EditorModuleController : AnyObject {
  static func renderNode(for module: EditorModule, in group: RenderGroupNode) -> RenderNode?
  var viewSource: ModuleViewSource { get }
  func getModule() -> EditorModule?
  func getRenderNode() -> RenderNode?
  func getTitleView() -> UIKit.UIView?
  func editorDidRestoreSnapshot()
  func viewSourceDidLayoutSubviews()
  func viewSourceTraitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  init(renderNode: RenderNode?, module: EditorModule, viewSource: ModuleViewSource)
}
extension EditorModuleController {
  public static func renderNode(for module: EditorModule, in group: RenderGroupNode) -> RenderNode?
  public func getTitleView() -> UIKit.UIView?
  public func getModule() -> EditorModule?
  public func getRenderNode() -> RenderNode?
  public func editorDidRestoreSnapshot()
  public func viewSourceDidLayoutSubviews()
  public func viewSourceTraitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
}
public protocol EditorModules : AnyObject {
  var all: [EditorModule] { get }
}
public protocol BoundedRangeCommandToolbarDelegate : AnyObject {
  func toolbarSliderChanged(slider: UIKit.UISlider, for command: BoundedRangeCommand)
  func toolbarSliderFinishedChanging(slider: UIKit.UISlider, for command: BoundedRangeCommand)
}
@objc public class BoundedRangeCommandToolbar : EditorToolbar {
  weak public var delegate: BoundedRangeCommandToolbarDelegate?
  public var command: BoundedRangeCommand {
    get
    set
  }
  public init(command: BoundedRangeCommand, style: EditorToolbarStyle = .default)
  @objc required dynamic public init(coder: Foundation.NSCoder)
  @objc deinit
  override public init(style: EditorToolbarStyle = super)
}
extension BoundedRangeCommandToolbar {
  public func updateValue(value: Swift.Double, at index: Swift.Int = 0)
}
public struct Constants {
  public struct Size {
  }
  public struct Spacing {
  }
  public struct Color {
  }
  public struct Margin {
  }
  public struct Misc {
  }
  public struct Animations {
  }
  public struct ViewEffects {
  }
}
extension Constants.Size {
  public static let defaultToolbarHeight: CoreGraphics.CGFloat
  public static let mediumToolbarHeight: CoreGraphics.CGFloat
  public static let largeToolbarHeight: CoreGraphics.CGFloat
  public static let segmentToolbarHeight: CoreGraphics.CGFloat
  public static let toolbarItem: CoreGraphics.CGSize
  public static let wideToolbarItem: CoreGraphics.CGSize
  public static let toolbarIcon: CoreGraphics.CGSize
  public static let maxImageInputSize: CoreGraphics.CGSize
}
extension Constants.Spacing {
  public static let toolbarItem: CoreGraphics.CGFloat
  public static let toolbarInset: CoreGraphics.CGFloat
  public static let insetContentLayout: UIKit.NSDirectionalEdgeInsets
}
extension Constants.Color {
  public static let background: UIKit.UIColor
  public static let moduleBackground: UIKit.UIColor
  public static let innerToolbar: UIKit.UIColor
  public static let defaultTint: UIKit.UIColor
  public static let primaryActionTint: UIKit.UIColor
}
extension Constants.Misc {
  public static let cropHandleRadius: CoreGraphics.CGFloat
  public static let cropLineThickness: CoreGraphics.CGFloat
  public static let cropOutsideOpacity: Swift.Float
}
extension Constants.Animations {
  public static func `default`(duration: Foundation.TimeInterval = 0.25, delay: Foundation.TimeInterval = 0, animations: @escaping () -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
extension Constants.ViewEffects {
  public static let blur: UIKit.UIBlurEffect
}
public protocol Editable {
  func applyEditing()
  func cancelEditing()
}
public protocol EditorModule : DescriptibleEditorItem {
  var isEnabled: Swift.Bool { get }
  var controllerType: EditorModuleController.Type { get }
  var nodeType: RenderGroupChildNode.Type? { get }
  var nodeCategory: RenderNodeCategory { get }
  var autocreatesNode: Swift.Bool { get }
}
extension CGPoint {
  public enum Metric {
    case euclidean
    case manhattan
    case maximum
    public static func == (a: CoreGraphics.CGPoint.Metric, b: CoreGraphics.CGPoint.Metric) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func distance(to point: CoreGraphics.CGPoint, metric: CoreGraphics.CGPoint.Metric = .euclidean) -> CoreGraphics.CGFloat
  public func euclideanDistance(to point: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
  public func manhattanDistance(to point: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
  public func maximumDistance(to point: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
}
public protocol RectCropGesturesHandlerDelegate : EditDataSource {
  func rectCropChanged(_ handler: RectCropGesturesHandler)
}
public class RectCropGesturesHandler {
  weak public var delegate: RectCropGesturesHandlerDelegate?
  public var croppedRect: CoreGraphics.CGRect {
    get
  }
  public var actualEdgeInsets: UIKit.UIEdgeInsets {
    get
  }
  public var keepAspectRatio: Swift.Bool {
    get
    set
  }
  public var aspectRatio: CoreGraphics.CGSize {
    get
    set
  }
  public var allowDraggingFromSides: Swift.Bool {
    get
    set
  }
  public init(delegate: RectCropGesturesHandlerDelegate, allowDraggingFromSides: Swift.Bool = true)
  @objc deinit
}
extension RectCropGesturesHandler {
  public func reset()
  public func handlePanGesture(recognizer: UIKit.UIPanGestureRecognizer, in targetView: UIKit.UIView)
}
@objc public protocol DiscardApplyToolbarDelegate : AnyObject {
  @objc func applySelected(sender: UIKit.UIButton?)
  @objc func discardSelected(sender: UIKit.UIButton?)
}
@objc @_inheritsConvenienceInitializers public class DiscardApplyToolbar : EditorToolbar {
  weak public var delegate: DiscardApplyToolbarDelegate?
  override public var items: [UIKit.UIView] {
    get
  }
  override public var spacing: CoreGraphics.CGFloat {
    get
    set
  }
  required override public init(style: EditorToolbarStyle = .default)
  @objc required dynamic public init(coder _: Foundation.NSCoder)
  override public func setItems(_ items: [UIKit.UIView] = [], animated: Swift.Bool = false)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class TitledImageButton : ToolbarButton {
  public var spacing: CoreGraphics.CGFloat
  @objc override dynamic public func titleRect(forContentRect contentRect: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func imageRect(forContentRect contentRect: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ToolbarButton : UIKit.UIButton {
  public var imageCornerRadius: CoreGraphics.CGFloat {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum EditorToolbarItemMode {
  case text
  case image
  case both
  public static func == (a: EditorToolbarItemMode, b: EditorToolbarItemMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct EditorToolbarItemStyle {
  public var textAlignment: UIKit.NSTextAlignment
  public var tintColor: UIKit.UIColor?
  public var spacing: CoreGraphics.CGFloat
  public var cornerRadius: CoreGraphics.CGFloat
  public var mode: EditorToolbarItemMode
  public init(_ build: (inout EditorToolbarItemStyle) -> Swift.Void)
}
public protocol CircleCropGesturesHandlerDelegate : EditDataSource {
  func circleCropChanged(_ handler: CircleCropGesturesHandler)
}
public class CircleCropGesturesHandler {
  weak public var delegate: CircleCropGesturesHandlerDelegate?
  public init(delegate: CircleCropGesturesHandlerDelegate)
  @objc deinit
}
extension CircleCropGesturesHandler {
  public var circleCenter: CoreGraphics.CGPoint {
    get
    set
  }
  public var circleRadius: CoreGraphics.CGFloat {
    get
    set
  }
  public var actualEdgeInsets: UIKit.UIEdgeInsets {
    get
  }
  public func handlePanGesture(recognizer: UIKit.UIPanGestureRecognizer, in targetView: UIKit.UIView)
  public func reset()
}
extension EditorToolbarStyle {
  public static let `default`: EditorToolbarStyle
  public static let modules: EditorToolbarStyle
  public static let segments: EditorToolbarStyle
  public static let twoRowSegments: EditorToolbarStyle
  public static let commands: EditorToolbarStyle
  public static let largeCommands: EditorToolbarStyle
  public static let boundedRangeCommand: EditorToolbarStyle
}
extension EditorToolbarItemStyle {
  public static let `default`: EditorToolbarItemStyle
  public static let textOnly: EditorToolbarItemStyle
  public static let round: EditorToolbarItemStyle
}
extension CGRect {
  public func scaled(by scale: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func translated(using point: CoreGraphics.CGPoint) -> CoreGraphics.CGRect
  public mutating func ensurePositiveSize()
}
extension CGPoint {
  public func movedBy(x: CoreGraphics.CGFloat = 0, y: CoreGraphics.CGFloat = 0) -> CoreGraphics.CGPoint
  public func scaledBy(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  public func adding(point: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public func substracting(point: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
}
extension CGSize {
  public func adding(width: CoreGraphics.CGFloat = 0, height: CoreGraphics.CGFloat = 0) -> CoreGraphics.CGSize
  public func scaledBy(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
}
extension UIColor {
  public static func fromBundle(_ name: Swift.String) -> UIKit.UIColor
}
extension UIImage {
  public static func fromBundle(_ name: Swift.String) -> UIKit.UIImage
}
extension CGPoint {
  public func rounded(rule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> CoreGraphics.CGPoint
}
extension CGSize {
  public func rounded(rule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> CoreGraphics.CGSize
}
extension CGRect {
  public func rounded(rule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> CoreGraphics.CGRect
  public func rounded(originRule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero, sizeRule: Swift.FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> CoreGraphics.CGRect
}
extension BoundedRangeFormat : Swift.Equatable {}
extension BoundedRangeFormat : Swift.Hashable {}
extension RenderNodeCategory : Swift.Equatable {}
extension RenderNodeCategory : Swift.Hashable {}
extension CoreGraphics.CGPoint.Metric : Swift.Equatable {}
extension CoreGraphics.CGPoint.Metric : Swift.Hashable {}
extension EditorToolbarItemMode : Swift.Equatable {}
extension EditorToolbarItemMode : Swift.Hashable {}
